<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>事件循环机制</title>
</head>
<body>
  <div>
    promise 在创建时, 直接调用了resolve. 因此, f1 马上被加入 PromiseJobs 队列. PromiseJobs = [f1]
    f2 被加入临时队列. PromiseFulfillReactions = [f2]
    输出 0, js所有代码执行结束, 开始执行 PromiseJobs 列队中的逻辑

    f1 出队执行, 输出1. 遇到一个新的 Promise 对象, 且直接调用了 resolve ,f3 进入 PromiseJobs 队列 PromiseJobs = [f3]
    f4 需要等到 f3 的执行结果, 所以进入临时队列. PromiseFulfillReactions = [f2, f4]

    f1执行结束, 可以得知 f1 返回了 undefined, 等价于 resolve(undefined). f1 有了结果, 所以 f2 进入 PromiseJobs 队列.  PromiseJobs = [f3, f2],PromiseFulfillReactions = [f4]

    发现 PromiseJobs 中还有任务, 开始执行 PromiseJobs 中的任务.
    f3 出队执行, 输出 2
    f3执行完毕, 返回 undefined, 因此 f4 进入 PromiseJobs 队列.  PromiseJobs = [f2, f4], PromiseFulfillReactions = []

    依次执行 f2 f4, 没有产生新的 job,  PromiseJobs 变为空, 当前循环结束.
  </div>


  <div>
    Promise 在创建时, 直接调用了 resolve, 所以 f1 进入 PromiseJobs 队列.  PromiseJobs = [f1]
    f2 需要等待 f1 的执行结果才能进入 PromiseJobs 队列中, f10 需要等待 f2, 所以 f2 f10 都进入临时队列. PromiseFulfillReactions = [f2, f10]
    输出 0, js所有代码执行结束. 开始执行 PromiseJobs 队列中的逻辑

    f1 出队并执行, f1 执行过程中, 遇到了新的 Promise, 并直接调用了 resolve, 所以 f3 的状态直接被固定, 进入 PromiseJobs 队列. PromiseJobs = [f3]
    f4 和 f5 需要等待 f3 的结果才能入 PromiseJobs 队列. 所以只能进入临时队列. PromiseFulfillReactions = [f2, f10, f4, f5]
    f1 逻辑代码执行完毕, 相当于 resolve(undefined) , f2 进入 PromiseJobs 队列.  PromiseJobs = [f3, f2], PromiseFulfillReactions = [f10, f4, f5]. 开始执行 PromiseJobs 队列中的逻辑

    f3 出队并执行, 输出 1, 逻辑代码执行完毕, f3 返回 undefined, 因此 f4 进入 PromiseJobs 队列.  PromiseJobs = [f2, f4], PromiseFulfillReactions = [f10, f5]. 开始执行 PromiseJobs 队列中的逻辑

    f2 出队并执行, 输出 1.1, 遇到新的 Promise, 新的 Promise 直接调用了 resolve, f6 直接进入 PromiseJobs 队列.  PromiseJobs = [f4, f6], f9 进入临时队列, PromiseFulfillReactions = [f10, f5, f9]
    f2 代码执行完毕, 返回 undefined, f10 进入 PromiseJobs , PromiseJobs = [f4, f6, f10], PromiseFulfillReactions = [f5, f9]. 开始执行 PromiseJobs 队列中的逻辑

    f4 出队并执行, 输入 2, 返回 undefined, f5 进入 PromiseJobs, PromiseJobs = [f6, f10, f5], PromiseFulfillReactions = [f9]. 开始执行 PromiseJobs 队列中的逻辑

    f6 出队并执行, 遇到了新的 Promise, 新的 Promise 直接调用了 resolve, f7 进入 PromiseJobs 队列, PromiseJobs = [f10, f5, f7], f8 进入临时队列.  PromiseFulfillReactions = [f9, f8].
    f6 执行完毕, 返回 undefined, f9 进入 PromiseJobs . PromiseJobs = [f10, f5, f7, f9].  PromiseFulfillReactions = [f8]. 开始执行 PromiseJobs 队列中的逻辑

    f10 出队并执行, 输出 3, PromiseJobs = [f5, f7, f9], PromiseFulfillReactions = [f8].  开始执行 PromiseJobs 队列中的逻辑

    f5 出队并执行, 输出 3.1,  PromiseJobs = [f7, f9], PromiseFulfillReactions = [f8].  开始执行 PromiseJobs 队列中的逻辑

    f7 出队并执行, 输入 4, 返回了 undefined, f8 进入 PromiseJobs 队列.  PromiseJobs = [f9, f8], PromiseFulfillReactions = [].  开始执行 PromiseJobs 队列中的逻辑

    f9 出队并执行, 输出 5, PromiseJobs = [f8], PromiseFulfillReactions = [], 开始执行 PromiseJobs 队列中的逻辑

    f8 出队并执行, 输出 6, PromiseJobs = [], PromiseFulfillReactions = [], 循环结束
  </div>
  <script src="./index.js"></script>
</body>
</html>
<!-- p = [f1]
pfr = [f2, f10]
0

开始执行 PromiseJobs
f1 出队并开始执行
p = [f3]
pfr = [f2, f10, f4, f5]
f1 执行完毕，返回undefined, p = [f3, f2], prf = [f10, f4, f5]

开始执行 PromiseJobs
f3 出队并开始执行
输出 1, 返回 undefined, p = [f2, f4], prf = [f10, f5]

开始执行 PromiseJobs
f2 出队并开始执行
输出 1.1, 遇到新的 promise, 并直接调用了 resolve, f6 直接入队, f9 入临时队列, p = [f4, f6], pfr = [f10, f5, f9]
f2 执行完毕, 返回 undefined, f10 入队, p = [f4, f6, f10], pfr = [f5, f9]

开始执行 PromiseJobs
f4 出队并开始执行
输出2, 返回 undefined, f5 入队, p = [f6, f10, f5], pfr = [f9]

开始执行 PromiseJobs
f6 出队并开始执行
遇到新的 Promise, 并直接调用了 resolve, f7 入队, f8 入临时队列, p = [f10, f5, f7] pfr = [f9, f8]
f6 执行完毕, 返回 undefined, f9 入队, p = [f10, f5, f7, f9] pfr = [f8]

开始执行 PromiseJobs
f10 出队并开始执行
输出3 p = [f5, f7, f9] pfr = [f8]

开始执行 PromiseJobs
f5 出队并开始执行
输出3.1 p = [f7, f9] pfr = [f8]

开始执行 PromiseJobs
f7 出队并开始执行
输出4, 返回 undefined, f8 入队, p = [f9, f8] pfr = []

开始执行 PromiseJobs
f9 出队并开始执行
输出5, p = [f8] pfr = []

开始执行 PromiseJobs
f8 出队并开始执行
输出6, p = [] pfr = [], over -->


